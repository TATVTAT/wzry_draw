#pragma once
#include <cstddef>
#include <cstdint>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ioctl.h>

/**
 * @file Kernel.h
 * @brief 内核驱动接口头文件，包含类型定义和 c_driver 类声明
 *
 * 这个头文件封装了对不同驱动的操作（GT/RT/通用驱动/ditpro），提供
 * 读写内存、获取模块基址等功能。
 *
 * 使用方法：
 * 1. 包含本文件：#include "Kernel.h"
 * 2. 创建驱动对象：c_driver driver;
 * 3. 初始化 PID：driver.initialize(pid);
 * 4. 使用 read/write 或模板函数访问进程内存
 */

// --------------------- 向量类型 ---------------------

/**
 * @brief 2D 向量
 */
struct Vector2A
{
    float X;
    float Y;
    Vector2A(float x = 0, float y = 0) : X(x), Y(y) {}
};

/**
 * @brief 3D 向量 (XYZ)
 */
struct Vector3A
{
    float X;
    float Y;
    float Z;
    Vector3A(float x = 0, float y = 0, float z = 0) : X(x), Y(y), Z(z) {}
};

/**
 * @brief 3D 向量 (XZY，适配部分游戏引擎坐标)
 */
struct Vector3
{
    float X;
    float Z;
    float Y;
    Vector3(float x = 0, float z = 0, float y = 0) : X(x), Z(z), Y(y) {}
};

// --------------------- 内存操作相关类型 ---------------------

/**
 * @brief 内存拷贝结构体，用于 ioctl 调用
 */
struct COPY_MEMORY
{
    pid_t pid;      ///< 目标进程 PID
    uintptr_t addr; ///< 内存地址
    void *buffer;   ///< 缓冲区
    size_t size;    ///< 数据长度
};

/**
 * @brief 模块基址结构体
 */
struct MODULE_BASE
{
    pid_t pid;      ///< 目标进程 PID
    char *name;     ///< 模块名称
    uintptr_t base; ///< 模块基址
};

/**
 * @brief Ditpro 驱动操作结构体
 */
struct Ditpro_uct
{
    int read_write;  ///< 读写操作标记
    pid_t pid;       ///< 目标进程 PID
    uintptr_t addr;  ///< 内存地址
    void *buffer;    ///< 数据缓冲区
    size_t size;     ///< 数据长度
    int wendi = 616; ///< 校验标记
};

/**
 * @brief 内核操作类型
 */
enum class OPERATIONS
{
    OP_INIT_KEY = 0x800,   ///< 初始化密钥
    OP_READ_MEM = 0x801,   ///< 读内存
    OP_WRITE_MEM = 0x802,  ///< 写内存
    OP_MODULE_BASE = 0x803 ///< 获取模块基址
};

// --------------------- 驱动类 ---------------------

/**
 * @brief 内核驱动操作类
 *
 * 提供对不同驱动（GT/RT/通用/ditpro）的读写操作接口，
 * 可通过模板函数读写任意类型数据。
 */
class c_driver
{
public:
    c_driver();
    ~c_driver();

    /**
     * @brief 初始化目标进程 PID
     * @param pid 目标进程 PID
     */
    void initialize(pid_t pid);

    /**
     * @brief 初始化驱动密钥
     * @param key 密钥
     * @return 成功返回 true
     */
    bool init_key(char *key);

    /**
     * @brief 从目标进程内存读取数据
     * @param addr 内存地址
     * @param buffer 缓冲区
     * @param size 数据长度
     * @return 成功返回 true
     */
    bool read(uintptr_t addr, void *buffer, size_t size);

    /**
     * @brief 向目标进程内存写入数据
     * @param addr 内存地址
     * @param buffer 缓冲区
     * @param size 数据长度
     * @return 成功返回 true
     */
    bool write(uintptr_t addr, void *buffer, size_t size);

    /**
     * @brief 模板读取指定类型数据
     * @tparam T 数据类型
     * @param addr 内存地址
     * @return 返回读取的数据
     */
    template <typename T>
    T read(uintptr_t addr)
    {
        T res{};
        if (read(addr, &res, sizeof(T)))
            return res;
        return {};
    }

    /**
     * @brief 模板写入指定类型数据
     * @tparam T 数据类型
     * @param addr 内存地址
     * @param value 数据
     * @return 成功返回 true
     */
    template <typename T>
    bool write(uintptr_t addr, T value)
    {
        return write(addr, &value, sizeof(T));
    }

    /**
     * @brief 获取模块基址
     * @param module_name 模块名称
     * @return 返回模块基址
     */
    uintptr_t getModuleBase(char *module_name);

private:
    int fd = -1;          ///< 驱动文件描述符
    pid_t pid;            ///< 目标进程 PID
    bool ditbool = false; ///< 是否使用 ditpro 驱动

    // --------------------- 内部辅助函数 ---------------------
    char *driver_path();
    char *RT();
    char *GT();
    char *find_driver_path();
    int OpenFd();
};
